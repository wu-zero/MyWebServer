# 目录
- [目录](#目录)
- [记录](#记录)
  - [目前进展](#目前进展)
    - [2020.03.12](#20200312)
    - [2020.03.29](#20200329)



# 记录
## 目前进展
### 2020.03.12
写了很长时间，终于把第一个版本写出来了，采用了epoll作为IO复用技术。只是实现了server和client之间简单的数据收发，未添加http协议的内容。  
**学到了：**  
* 熟悉了`socket(sys/socket.h)`的创建、绑定、监听、连接、读写等；对`epoll`的机制更加理解(linux内核的select、poll、epoll机制也太奇妙了)，同时也更熟悉`epoll(sys/epoll.h)`的创建、事件的注册、等待事件处理回调等。  
* 另外学到的就是Channel类，自己也实现了一下，确实好用。每一个Channel对象对应一个Socket文件描述符，设置好要监听的事件以及对应的回调函数，根据监听到的事件类型执行相应的回调函数。  

### 2020.03.29
第二个版本，添加了IUser接口便于实现底层功能和顶层功能的分离，添加了Buffer类(功能见下)，EventLoop里通过Eventfd机制实现异步处理事件的能力。尝试分析了每个资源(类对象、socket资源等)的生命周期和资源删除时的相关操作(关闭fd、epoll里删除等)，感觉还是有bug。  
**学到了:**
* 通过IUser接口，将底层网络功能和顶层用户功能相关的内容分开，以后顶层功能是http相关内容，现在只是简单的数据接收显示和发送。  
* 学到了Buffer类，既可以用于发送缓冲，也可以用于接收缓冲。接收缓冲：TCP是一个无边界的字节流协议，用户更方便读想要的数据；发送缓冲：顶层用户通过TcpConnection::send()来告诉底层网络库它要发的数据，网络库没发送的数据由发送缓冲保存，并开始关注可写事件，以发送剩余的数据。  
* TcpServer类负责管理Acceptor和Connection，前者负责建立连接，后者负责每个连接，Connection关闭时通过回调让TcpServer类删除与自己有关的内容。  
* 处理socket对端关闭，还没处理socket相关异常。  